#if 0
Do not attempt to compile this file with a Java compiler such as javac.
You first need to preprocess it with cpp, the C preprocessor.
The correct way to build the system is to run 'make'.
#endif

#define stringify(NAME) #NAME

// ***** This file is automatically generated from MathMDE.java.jpp

package plume;

import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;

/*>>>
import org.checkerframework.checker.nullness.qual.*;
*/

/** Mathematical utilities. */
public final class MathMDE {

  /** This class is a collection of methods; it does not represent anything. */
  private MathMDE() {
    throw new Error("do not instantiate");
  }


  ///
  /// Function versions of Java operators
  ///

  /** Negates its argument.
   * @param a value to negate
   * @return negative of a
   */
  public static int negate(int a) {
    return -a;
  }

  /** Negates its argument.
   * @param a value to negate
   * @return negative of a
   */
  public static long negate(long a) {
    return -a;
  }

  /** Negates its argument.
   * @param a value to negate
   * @return negative of a
   */
  public static double negate(double a) {
    return -a;
  }

  /** Returns ~a, the bitwise complement of its argument.
   * @param a value to bitwise-complement
   * @return ~a, the bitwise complement of a
   */
  public static int bitwiseComplement(int a) {
    return ~a;
  }

  /** Returns ~a, the bitwise complement of its argument.
   * @param a value to bitwise-complement
   * @return ~a, the bitwise complement of a
   */
  public static long bitwiseComplement(long a) {
    return ~a;
  }

  /** Multiplies its arguments.
   * @param x first multiplicand
   * @param y second multiplicand
   * @return x * y
   */
  public static int mul(int x, int y) {
    return x * y;
  }

  /** Multiplies its arguments.
   * @param x first multiplicand
   * @param y second multiplicand
   * @return x * y
   */
  public static long mul(long x, long y) {
    return x * y;
  }

  /** Multiplies its arguments.
   * @param x first multiplicand
   * @param y second multiplicand
   * @return x * y
   */
  public static double mul(double x, double y) {
    return x * y;
  }

  /** Divides its arguments.
   * @param x dividend
   * @param y divisor
   * @return x / y
   */
  public static int div(int x, int y) {
    return x / y;
  }

  /** Divides its arguments.
   * @param x dividend
   * @param y divisor
   * @return x / y
   */
  public static long div(long x, long y) {
    return x / y;
  }

  /** Divides its arguments.
   * @param x dividend
   * @param y divisor
   * @return x / y
   */
  public static double div(double x, double y) {
    return x / y;
  }

  /** Returns x % y, the modulus operation applied to its arguments.
   * @param x valued to be modded
   * @param y modulus
   * @return x % y
   */
  public static int mod(int x, int y) {
    return x % y;
  }

  /** Returns x % y, the modulus operation applied to its arguments.
   * @param x valued to be modded
   * @param y modulus
   * @return x % y
   */
  public static long mod(long x, long y) {
    return x % y;
  }

  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.
   * @param x valued to be left-shifted
   * @param y magnitude of the left-shift
   * @return x &lt;&lt; y
   */
  public static int lshift(int x, int y) {
    return x << y;
  }

  /** Returns x &lt;&lt; y, the left-shift operation applied to its arguments.
   * @param x valued to be left-shifted
   * @param y magnitude of the left-shift
   * @return x &lt;&lt; y
   */
  public static long lshift(long x, long y) {
    return x << y;
  }

  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.
   * @param x valued to be right-shifted
   * @param y magnitude of the right-shift
   * @return x &gt;&gt; y
   */
  public static int rshiftSigned(int x, int y) {
    return x >> y;
  }

  /** Returns x &gt;&gt; y, the signed right-shift operation applied to its arguments.
   * @param x valued to be right-shifted
   * @param y magnitude of the right-shift
   * @return x &gt;&gt; y
   */
  public static long rshiftSigned(long x , long y) {
    return x >> y;
  }

  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.
   * @param x valued to be right-shifted
   * @param y magnitude of the right-shift
   * @return x &gt;&gt;&gt; y
   */
  public static int rshiftUnsigned(int x, int y) {
    return x >>> y;
  }

  /** Returns x &gt;&gt;&gt; y, the unsigned right-shift operation applied to its arguments.
   * @param x valued to be right-shifted
   * @param y magnitude of the right-shift
   * @return x &gt;&gt;&gt; y
   */
  public static long rshiftUnsigned(long x, long y) {
    return x >>> y;
  }

  /** Returns x &amp; y, the bitwise and of its arguments.
   * @param x first operand
   * @param y second operand
   * @return x &amp; y
   */
  public static int bitwiseAnd(int x, int y) {
    return x & y;
  }

  /** Returns x &amp; y, the bitwise and of its arguments.
   * @param x first operand
   * @param y second operand
   * @return x &amp; y
   */
  public static long bitwiseAnd(long x, long y) {
    return x & y;
  }

  /** Returns the logical and of its arguments.  The result is always 0 or 1.
   * @param x first operand
   * @param y second operand
   * @return the logical and of x and y; the result is always 0 or 1
   */
  public static int logicalAnd(int x, int y) {
    return ((x!=0) && (y!=0)) ? 1 : 0;
  }

  /** Returns the logical and of its arguments.  The result is always 0 or 1.
   * @param x first operand
   * @param y second operand
   * @return the logical and of x and y; the result is always 0 or 1
   */
  public static long logicalAnd(long x, long y) {
    return ((x!=0) && (y!=0)) ? 1 : 0;
  }

  /** Returns x ^ y, the bitwise xor of its arguments.
   * @param x first operand
   * @param y second operand
   * @return x ^ y
   */
  public static int bitwiseXor(int x, int y) {
    return x ^ y;
  }

  /** Returns x ^ y, the bitwise xor of its arguments.
   * @param x first operand
   * @param y second operand
   * @return x ^ y
   */
  public static long bitwiseXor(long x, long y) {
    return x ^ y;
  }

  /** Returns the logical xor of its arguments.  The result is always 0 or 1.
   * @param x first operand
   * @param y second operand
   * @return the logical xor of x and y; the result is always 0 or 1
   */
  public static int logicalXor(int x, int y) {
    return ((x!=0) ^ (y!=0)) ? 1 : 0;
  }

  /** Returns the logical xor of its arguments.  The result is always 0 or 1.
   * @param x first operand
   * @param y second operand
   * @return the logical xor of x and y; the result is always 0 or 1
   */
  public static long logicalXor(long x, long y) {
    return ((x!=0) ^ (y!=0)) ? 1 : 0;
  }

  /** Returns x | y, the bitwise or of its arguments.
   * @param x first operand
   * @param y second operand
   * @return x | y
   */
  public static int bitwiseOr(int x, int y) {
    return x | y;
  }

  /** Returns x | y, the bitwise or of its arguments.
   * @param x first operand
   * @param y second operand
   * @return x | y
   */
  public static long bitwiseOr(long x, long y) {
    return x | y;
  }

  /** Returns the logical or of its arguments.  The result is always 0 or 1.
   * @param x first operand
   * @param y second operand
   * @return the logical or of x and y; the result is always 0 or 1
   */
  public static int logicalOr(int x, int y) {
    return ((x!=0) || (y!=0)) ? 1 : 0;
  }

  /** Returns the logical or of its arguments.  The result is always 0 or 1.
   * @param x first operand
   * @param y second operand
   * @return the logical or of x and y; the result is always 0 or 1
   */
  public static long logicalOr(long x, long y) {
    return ((x!=0) || (y!=0)) ? 1 : 0;
  }


  ///
  /// sign
  ///

  /** Returns the sign of its argument.  The result is always -1, 0, or 1.
   * @param a value to have its sign taken
   * @return the sign of a: -1, 0, or 1
   */
  public static int sign(int a) {
    if (a==0) {
      return 0;
    } else if (a>0) {
      return 1;
    } else {
      return -1;
    }
  }


  ///
  /// exponentiation
  ///

  /**
   * Returns of value of the first argument raised to the
   * power of the second argument.  The argument are integers.
   * @param base the base
   * @param expt the exponent
   * @return base to the expt power
   * @see Math#pow(double, double)
   */
  public static int pow(int base, int expt) throws ArithmeticException {
    return pow_fast(base, expt);
  }

  /**
   * Returns of value of the first argument raised to the
   * power of the second argument.
   * @param base the base
   * @param expt the exponent
   * @return base to the expt power
   * @see Math#pow(double, double)
   */
  public static long pow(long base, long expt) throws ArithmeticException {
    return pow_fast(base, expt);
  }

  private static int pow_fast(int base, int expt) throws ArithmeticException {
    if (expt < 0) {
      throw new ArithmeticException("Negative exponent passed to pow");
    }

    int this_square_pow = base;
    int result = 1;
    while (expt>0) {
      if ((expt & 1) != 0) {
        result *= this_square_pow;
      }
      expt >>= 1;
      this_square_pow *= this_square_pow;
    }
    return result;
  }

  private static long pow_fast(long base, long expt) throws ArithmeticException {
    if (expt < 0) {
      throw new ArithmeticException("Negative exponent passed to pow");
    }

    long this_square_pow = base;
    long result = 1;
    while (expt>0) {
      if ((expt & 1) != 0) {
        result *= this_square_pow;
      }
      expt >>= 1;
      this_square_pow *= this_square_pow;
    }
    return result;
  }

  private static int pow_slow(int base, int expt) throws ArithmeticException {
    if (expt < 0) {
      throw new ArithmeticException("Negative exponent passed to pow");
    }

    int result = 1;
    for (int i=0; i<expt; i++) {
      result *= base;
    }
    return result;
  }

  ///
  /// gcd
  ///

#define INT int
#include "MathMDE-gcd.java.jpp"
#undef INT

  /// gcd -- version for manipulating long (rather than int) values

#define INT long
#include "MathMDE-gcd.java.jpp"
#undef INT

#define INT double
#define GCD_DOUBLE
#include "MathMDE-gcd.java.jpp"
#undef INT
#undef GCD_DOUBLE

  ///
  /// Modulus
  ///

#define PARAM_INT
#include "MathMDE-modulus.java.jpp"
#undef PARAM_INT

  /// modulus for long (as opposed to int) values

#define PARAM_LONG
#include "MathMDE-modulus.java.jpp"
#undef PARAM_LONG


  ///
  /// Non-Modulus
  ///

#define PARAM_INT
#include "MathMDE-nonmodulus.java.jpp"
#undef PARAM_INT

  /// non-modulus for long (as opposed to int) values

#define PARAM_LONG
#include "MathMDE-nonmodulus.java.jpp"
#undef PARAM_LONG


}
